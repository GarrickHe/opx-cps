#!/usr/bin/python
#
# Copyright (c) 2016 Dell Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
#
# THIS CODE IS PROVIDED ON AN #AS IS* BASIS, WITHOUT WARRANTIES OR
# CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
#  LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS
# FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.
#
# See the Apache Version 2.0 License for specific language governing
# permissions and limitations under the License.
#
import sys
import subprocess
import cps
import cps_utils

def run_cmd_get_output(cmdline) :
    """
    Execute any command from python file
    @params[in] cmdline - command line to execute
    @returns Output from the command line execution
    """

    try:
        p = subprocess.Popen(cmdline,stdout=subprocess.PIPE)

        result = p.wait();
        details = p.stdout.read()

        if result != 0:
            exit(1)

        return details.split('\n')
    except :
        #print( sys.exc_info())
        pass
    return [""]


def find_process_names():
    #Construct a dictionary of pid to process names
    #ps = {pid: process name}
    ps = {}

    #Get all running processes from the system
    ret = run_cmd_get_output(['ps', '-ef'])
    for proc in ret:
        pr = proc.split()
        if len(pr) > 1:
            pid = pr[1]
            if pr[7] == "/usr/bin/python":
                proc_name = pr[8].split('/')[-1]
            else:
                proc_name = pr[7].split('/')[-1]

            ps[pid] = proc_name

    return ps


def registered(path):

     qual = ["target", "observed", "proposed", "realtime"]
     # Check to see Object Registration
     for q in qual:
        key = cps.key_from_name(q, path)
        if (cps.enabled(key)):
            print "\nRegistered to CPS with qualifier: ", q

            # Find Ownership
            stats = cps.obj_stats(key)
            if bool(stats) != False:
                if 'cps/object/operations/process_id' in stats['data']:
                    pid = cps_utils.cps_attr_types_map.from_data('cps/object/operations/process_id' , stats['data']['cps/object/operations/process_id'])

                    ps = find_process_names()
                    if str(pid) in ps.keys():
                        process_owner = ps[str(pid)]
                        print "\nProcess Owner: ", process_owner, "\n"



def yangwalk(yangpath):
    """
    YANG data model walk
    @params[in] yangpath - Input yang path to fetch its first level contents
    @returns None
    """
        
    if yangpath == '':
        # Find the modules
        i = cps.info("")['names'].keys()
        for mod in i:
            print mod
        return


    if cps.type(yangpath)['attribute_type'] == "leaf":
        #Print YANG leaf attributes
        print "Name = ", cps.type(yangpath)['name'], "\nAttribute Type = ", cps.type(yangpath)['attribute_type'], "\nData Type = ", cps.type(yangpath)['data_type'], "\nDescription = ", cps.type(yangpath)['description']
        registered(yangpath)
        return


    slashes = cps.type(yangpath)['name'].count("/")
    complist = cps.info(yangpath, False)['names'].keys()

    #Print first level contents of the specified YANG path
    for elem in complist:
        if cps.type(elem)['name'].count("/") == slashes+1:
            print "\n", cps.type(elem)['name']
            print "\tAttribute Type = ", cps.type(elem)['attribute_type']
            if cps.type(elem)['attribute_type'] == "leaf":
                print "\tData Type = ", cps.type(elem)['data_type']
            print "\tDescription = ", cps.type(elem)['description']
            registered(elem)


if __name__ == "__main__":

    # Usage: python cps_model_info.py [yangpath]
    if len(sys.argv) >= 2:
        yangpath = sys.argv[1]
    else:
        yangpath = ''

    yangwalk(yangpath)

    sys.exit(0)


